# 웹 폰트 최적화

## 1. 웹 폰트 정의
Hi! I'm your first Markdown file in **StackEdit**. If you want to learn about StackEdit, you can read me. If you want to play with Markdown, you can edit me. Once you have finished with me, you can create new files by opening the **file explorer** on the left corner of the navigation bar.


## 1. 웹 폰트 문제점

Hi! I'm your first Markdown file in **StackEdit**. If you want to learn about StackEdit, you can read me. If you want to play with Markdown, you can edit me. Once you have finished with me, you can create new files by opening the **file explorer** on the left corner of the navigation bar.


## 웹 폰트를 다운로드해 웹 페이지를 렌더링하는 과정

![enter image description here](https://d2.naver.com/content/images/2018/12/helloworld-201812-webfont_04.png)  

웹 폰트 다운로드 과정(원본 출처: "<a  href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/webfont-optimization">웹 글꼴 최적화</a>
1. HTML 문서 요청 브라우저는 HTML을 읽어서 DOM을 구성
4. 브라우저는 CSS, JS 및 기타 리소스를 검색하고 요청을 전달합니다.
5. 브라우저는 모든 CSS 콘텐츠가 수신 된 후 CSSOM을 구성하고 이를 DOM 트리와 결합(어태치먼트Attatchment)하여 렌더링 트리를 구성합니다.
   
   렌더 트리가 페이지에서 지정된 텍스트를 렌더링하는 데 필요한 글꼴 변형을 표시 한 후 글꼴 요청이 전달됩니다.


  - 문제는 [ CSSOM(CSS Object Model) 생성 과정 ]
    이 과정에서 외부 웹 폰트 링크로 정의된 부분을 만나고 해당 폰트 파일을 다운로드하기 시작한다. 하지만 그리기(paint) 단계에서 웹 폰트 파일처럼 외부 링크로 연결된 파일의 다운로드가 완료되지 않았으면 브라우저는 해당 자원을 사용하는 콘텐츠의 렌더링을 차단한다. 
    => 화면에 텍스트 보이지 않는 현상이 발생


5. 브라우저는 레이아웃을 수행하고 콘텐츠를 화면에 그립니다.
  - 글꼴을 아직 사용할 수없는 경우 브라우저에서 텍스트 픽셀을 렌더링하지 못할 수 있습니다.
  - 글꼴을 사용할 수있게되면 브라우저가 텍스트 픽셀을 그립니다.





The web browser examines your HTML and builds the DOM (Document Object Model). 
The web browser examines your CSS and builds the CSSOM (CSS Object Model).
The web browser combines the DOM and the CSSOM to create a render tree.
The web browser displays your webpage.





## 폰트 선언 순서
브라우저가 폰트를 가져올 때 지원하는 형식 중 가장 첫번째 형식을 가져오게 된다. 

<img src="/content/images/2018/12/helloworld-201812-webfont_06.png" alt="그림 6 폰트 형식별 브라우저 지원 상황">
<p><span class="caption">그림 6 폰트 형식별 브라우저 지원 상황(원본 출처: <a href="https://www.w3schools.com/Css/css3_fonts.asp">CSS Web Fonts</a>)</span></p>

<p><img src="/content/images/2018/12/helloworld-201812-webfont_07.png" alt="그림 7 폰트 형식 적용 순서로 최적화한 @font-face 규칙"></p>
<p><span class="caption">그림 7 폰트 형식 적용 순서로 최적화한 <code>@font-face</code> 규칙</span></p>



## 일반적인 가중치 이름 매핑

100~900 의 가중치 값들은 다음의 일반적인 두께 이름으로 대응된다.
|NAME                       | WEIGHT |
|---------------------------|--------|
|Thin (Hairline)            | `100` |
|Extra Light (Ultra Light)  | `200` |
|Light                      | `300` |
|Normal                     | `400` |
|Medium                     | `500` |
|Semi Bold (Demi Bold)      | `600` |
|Bold                       | `700` |
|Extra Bold (Ultra Bold)    | `800` |
|Black (Heavy)              | `900` |



## 요약



### 관련 용어


### 참고
https://developer.mozilla.org/ko/docs/Web/API/CSS_Object_Model
https://frontdev.tistory.com/entry/CSSOM-%EB%A0%8C%EB%8D%94%EB%A7%81

https://showerbugs.github.io/2018-02-02/%EC%9B%B9%ED%8F%B0%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94-%ED%95%98%EA%B8%B0

https://d2.naver.com/helloworld/4969726




https://shylog.com/googlefonts-and-webfont-optimization/



Front-End
https://github.com/kamranahmedse/developer-roadmap
https://raw.githubusercontent.com/kamranahmedse/developer-roadmap/master/img/frontend.png
2017버전 : https://t1.daumcdn.net/cfile/tistory/2560A33B58FE281731

1. 주요 용어 
1-1) Platform : 어플리케이션을 작동시키기 위한 "기반 OS"나 "기술환경"
      1. 하드웨어 플랫폼
      2. 소프트웨어 플랫폼 : 여러가지 기능들을 제공해주는 공통 실행환경 ( 브라우저, JAVA ...)
      3. 서비스 플랫폼 (SNS)

1-2) Framework : 특정 프로그램을 개발하기 위한 여러 요소들과 메뉴얼인 룰을 제공하는 프로그램
               : AngularJS, Vue, Spring, Django, Ruby on Rails, Bootstrap

1-3) library : 개발 도구의 모음입니다.

1-4) Moudle Bundling : 웹 애플리케이션을 구성하는 몇십, 몇백개의 자원들을 하나의 파일로 병합 및 압축 해주는 동작
모듈 : 웹 애플리케이션을 제작에 필요한 HTML, CSS, Javascript, Images, Font 등 이 파일 하나하나가 모두 모듈
번들러 : 소프트웨어 및 일부 하드웨어와 함께 작동하는데 필요한 모든 것을 포함하는 패키지

1-6) Pre-Processor(전처리기)
컴파일러가 소스 파일을 컴파일하기 전에 먼저 수행되는 프로그램(처리기)

1-7) TDD(Test Driven Development) : 테스트 주도 개발

1-8) 하드웨어 생산자는 퍼스트 파티(first party)로, 소프트웨어 개발자는 서드 파티(third party)

1-9) 정적, 동적
정적은 컴파일 시점, 동적은 런타임 시점에 타입이 체크되어진다

1-10) Node.js
Node.js는 웹브라우저에 종속적인 자바스크립트를 ( Chrome V8 엔진을 제공하여) 브라우저 외의 다른 환경에서도 사용할 수 있게 해주는 소프트웨어 플랫폼 (런타임?) 입니다.
http서버가 내장되어 있기 때문에 보통은 서버로 많이 사용합니다.


2. Package Managers(패키지 매니저) 
: 패키지를 다루는 작업을 편리하고 안전하게 수행하기 위해 사용되는 툴이다.
: 여기서 패키지를 다루는 작업이란 패키지를 설치, 업데이트, 수정, 삭제하는 작업을 의미한다.

2-1) npm : node package manager
Node.js에서는 자주 쓰이고 재사용되는 자바스크립트 코드들을 패키지로 만들어서 사용 가능.
이런 패키지를 모아놓은 저장소가 npm.
Node.js를 설치하면 자동으로 npm이 설치.
package.json : 패키지명과 함께 패키지 버전도 관리

[주요 명령어]
npm install : npm 설치
npm -v : 버전 체크
npm update -g npm : 최신 버전 업데이트
npm init : package.json 생성
const 변수이름 = require(패키지이름) : 패키지 사용

2-2) yarn : 자바스크립트의 새로운 패키지 매니저
페이스북, Exponent, 구글과 Tilde의 엔지니어 그룹들이 함께 협력하여 npm의 핵심 이슈를 해결하기 위해 만든 패키지 매니저.
이 새로운 자바스크립트 패키지 매니저가 얀(Yarn)이다. 보다 빠르고 안정적이며 보안성이 뛰어나다고 주장하고 있다.


3. CSS
2-1) CSS Architecture 
- BEM (Block Element Modifier)
- OOCSS(Object Oriented CSS)
- SMACSS (Scalable Modular Architecture CSS)

2-2) CSS Preprocessor 
	sass(언어), postcss(자바스크립트 기반의 플러그인을 사용하여 CSS 기능을 자동화하는 소프트웨어 개발 도구), less(언어), stylus 




3. JavaScript
https://t1.daumcdn.net/cfile/tistory/9997C73359B2B4011C

3-1) 클래스 > 객체 > 인스턴스
클래스는 틀(설계도)이고 : 연관 변수(필드)와 메소드로 구성
객체는 추상적 대상 선언(설계도로 지은 집) : 속성과 메소드로 구성
인스턴스는 구체적 실체화(설계도로 지은 내집)라고 보면 된다 : 메모리에 할당된 객체 , 생성된 복제본을 의미
* 클래스로부터 객체를 선언하는 과정을 클래스의 인스턴스 화


* 스택 : 후입선출 자료 구조  
* 스코프 : 함수 범위
* 메소스 : 객체와 관련된 함수
* lexical scope : 접근 가능한 범위
* 클로저 : 함수 안에서 선언된 내부함수(익명함수)로 접근 범위는 lexical scope

* 이벤트 루프 : 호출 스택이 비워지면 태스크 큐에서 함수를 하나씩 호출 스택으로 밀어 올립니다.
* 이벤트 버블링 : 자식의 이벤트가 부모에도 전달되는 것
* 이벤트 드리븐(이벤트 기반) : 이벤트가 발생할 때 미리 지정해 둔 작업을 수행하는 것 (일련의 동작을 정의하고 등록된 상태가 이벤트 리스너에 등록된 상태)

* Synchronous (작업 순서 보장) VS Asynchronous (작업 순서 비보장) : 구분 기준은 작업 순서
* Blocking(작업의 멈춤, 대기(Wait)) VS Non-Blocking(대기(Wait) 없음) : 구분 기준은 통지(제어권)
  - Blocking : 작업을 시작하고 작업이 끝날때까지 대기하다가 즉석에서 완료 통지를 받는다.(작업이 멈추는 동안 다른작업이 끼어들수 있는지 없는지는 다른 얘기)
  - Non-Blocking : 대기 없이 완료시킨 후 나중에 통지받는 개념 (작업의 시작 이후 완료시까지 대기하지 않고, 완료시킨다.)

[ locking-NonBlocking-Synchronous-Asynchronous ]
Sync-Blocking : 작업순서는 보장. 호출에서 반환까지 대기
Sync-NonBlocking : 작업순서 보장. 호출(콜백)에서 반환까지 대기 없이 완료.
Async-Blocking : 작업순서도 비보장. 호출에서 반환까지 대기 
Async-NonBlocking : 작업순서 비보장. 호출(콜백)에서 반환까지 대기 없이 완료.  
https://jins-dev.tistory.com/entry/%EB%8F%99%EA%B8%B0Synchronous-%EC%9E%91%EC%97%85%EA%B3%BC-%EB%B9%84%EB%8F%99%EA%B8%B0Asynchronous-%EC%9E%91%EC%97%85-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%B8%94%EB%9D%BDBlocking-%EA%B3%BC-%EB%84%8C%EB%B8%94%EB%9D%BDNonBlocking-%EC%9D%98-%EA%B0%9C%EB%85%90
https://heecheolman.tistory.com/48
http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/
* setTimeout 0도 기본적으로 4ms의 지연 시간을 노드는 1ms의 지연 시간을 갖고 있습니다.


3-2) OOP(객체지향프로그래밍)의 형태
1. 캡슐화 (Encapsulation)
2. 상속 (Inheritance)
3. 다형성 (Polymorphism)
4. 추상화 (Abstraction)

클래스(일반 언어  C++, JAVA) 기반 VS 프로토타입 (자바스크립트) 기반
* 차이점 : 클래스와 인스턴스
* 클래스 -> 클래스는 틀이고, 인스턴스는 클래스가 실체화된 것
      -> 즉, 클래스는 클래스로부터 상속되고 하위클래스와의 관계가 만들어진다. (계층구조)
* 프로토타입 -> 프로토타입은 클래스와 인스턴스의 차이를 두지 않는다.
          -> 실체화된 객체로써, 객체는 다른 객체로부터 상속된다.


3-3) Node.JS 






1) Webpack : 모듈 번들러(Module Bundler)입니다.


2) Babel

3) ESLint








Vue.js

Vue


npm


* Node.JS 내장 모듈은 검색해서 사용



* Runtime 런타임 : 어떤 프로그램이 실행되는 동안의 Time
* Compile tiem 컴파일타임 : 고급 언어(프로그래밍 언어)를 기계어로 변경하는 과정



[JS Enjine]
<img src="https://miro.medium.com/max/2048/1*4lHHyfEhVB0LnQ3HlhSs8g.png">

* Web API : 자바스크립트 엔진이 아닌 브라우저에서 제공하는 API (DOM, Ajax, Timeout, requestAnimationFrame, Promise 등)


* Stack(스택) : 자료구조 중 하나, 후입선출(LIFO, Last In First Out)의 룰을 따른다.

* Queue(큐) : 자료 구조 중 하나, 선입선출(FIFO, Frist In Frist OUT)의 룰을 따른다.
[ Callback Queue 순서 ] 
Microtask Queue(Job Queue) : Promise의 then() 의 콜백
Animation Frames : requestAnimationFrame
Task Queue(Event Queue) : setTimeout 콜백

Event Loop는 Call Stack과 Callback Queue의 상태를 체크하여,
Call Stack이 빈 상태가 되면, Callback Queue의 첫번째 콜백을 Call Stack으로 밀어넣는다.
이러한 반복적인 행동을 틱(tick) 이라 부른다.


* MongoDB 자바스크립트로 된 데이터베이스
* LESS 자바스크립트로 된 CSS


* LTS 여러 버전이 동시에 지원되면서 순차적으로 종료해나가는 시스템